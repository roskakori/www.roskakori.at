<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Vahunz - Beyond Vahunz</TITLE>
<LINK REV="owns" TITLE="Thomas Aglassinger" HREF="mailto:agi@giga.or.at">
<LINK REL="Next" HREF="problems.html">
<LINK REL="Copyright" HREF="legal.html">
<LINK REL="Previous" HREF="inside.html">
<META name="ROBOTS" content="NOINDEX, NOFOLLOW">
</HEAD><BODY>
<A HREF="index.html"><IMG SRC="image/main.gif" ALT="Contents" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<IMG SRC="image/noindex.gif" ALT="-----" ALIGN="middle" WIDTH="70" HEIGHT="16">
<A HREF="legal.html"><IMG SRC="image/copy.gif" ALT="Copyright" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="inside.html"><IMG SRC="image/prev.gif" ALT="Previous" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="problems.html"><IMG SRC="image/next.gif" ALT="Next" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<HR>
<H1>Beyond Vahunz</H1>
<p>As already stated, the way Vahunz works is not perfect, but a
trade-off between efficiency, flexibility and programming effort. Here
are some comments on other applications that perform related
tasks.</p>
<h2><a name="strip-tools">Strip Tools</a></h2>
<p>Strip tools are used to remove comments and unused white space from
a source code. Especially for idiotic languages like C and C++ they
were quite popular some time ago, as stripped include files could
speed up the compilation and reduce the amount of disk space required
to store them.</p>
<p>Nowadays, disk space does not matter any more and most compilers
for idiotic languages support an even more idiotic feature commonly
called something like "precompiled header files". Therefor such
utilities are not so widely used anymore.</p>
<p>One such tool can be found in <A HREF="http://wuarchive.wustl.edu/~aminet/dirs/aminet/dev/c/stripc.lha">aminet:dev/c/stripc.lha</A>.</p>
<p>It might make sense to use them together with Vahunz, as they
usually know more details about a certain language. Take a look at the
following excerpt of a C source code (a period (<code>.</code>) represents a
blank):</p>

<pre>
struct.person
{
..unsigned.char.name.[20];
..int...........age;
};
</pre>
When Vahunz removes white space, it turns into

<pre>
struct.person
{
unsigned.char.name.[20];
int.age;
};
</pre>
<p>But a good strip tool knows that it can also remove every kind of
white space before and after a bracket or semicolon (<code>;</code>), and therefor
would generate:</p>

<pre>
struct.person{unsigned.char.name[20];int.age;};
</pre>
<p>So basically, every source code can be stored in one single
line (except for preprocessor commands).</p>
<p>That's of course is not totally true for idiotic languages like C
and C++, because the have an inferior concept called "preprocessor",
which detects commands like</p>

<pre>
#include "hugo/sepp.h"
</pre>
<p>only at the beginning of a line.</p>
<p>At least you should now understand why there is some room for
improvements left in a Vahunz-stripped output. It it should also be
clear why such improvements will not happen because the whole issue is
completely sick when it comes to C and C++.</p>
<h2><a name="indent-tools">Indent Tools</a></h2>
<p>Indent tools are popular to keep a consistent indention style
within your source code. A well-known example for such a program is
GNUindent, available from <A HREF="http://wuarchive.wustl.edu/~aminet/dirs/aminet/dev/c/indent191.lha">aminet:dev/c/indent191.lha</A>.
Usually, they simply add white space and linefeeds to the source code
to make it more legible.</p>
<p>In context with Vahunz they are only useful for <a
href="use-case-5.html">Unvahunzing</a>. However, many of then are
quite flexible, so you can configure them to glue lines together,
something clumsy strip tools often do not. See the example code
excerpt from <a href="#strip-tools">strip tools</a>.</p>
<h2>Compilers</h2>
<p>Ideally, only one application should be responsible for
vahunzation: the compiler itself. The reasons are obvious:</p>
<ul>
<li>The compiler does not need to maintain any stupid dictionaries,
because it already knows which names are reserved words, "exported" to
other modules or simple internal ones that can be vahunzed.
<li>The compiler already creates an "abstract" version of the source code
in memory. All it would need to do is write it out. (At least a clean
compiler for a clean language works like that.)
</ul>
<p>Furthermore, the project management environment already knows about
all files that should be vahunzed, and can easily tell the compiler
about that.</p>
<p>(There is the problem that many people still believe that compiler
and project management are two completely different beasts and that
crappy Makefiles are a great thing. But those people never have heard
of Modula-2 or Oberon, so don't listen to them.)</p>
<p>An more integrated approach could also address the problem that
possibly meaningful filenames are preserved.</p>
<p>All these things would simplify the whole process a lot.</p>
<p>As an addition, not only the source code can be vahunzed, but also
the binary. Especially with "semi-interpreters" like Java, the
compiled binary still contains a lot of information about the original
source code because names of methods and attributes have to be stored
to allow (possibly distributed) dynamic binding and other stuff during
run-time. Therefor it is a pretty simple task to translate a
<i>*.class</i> into a quite legible <i>*.java</i>.</p>
<p>Of course for public modules, there is no way around storing heaps
of information in the binary. But for modules which only contain
internal functions, all names can be vahunzed. An ad-hoc
implementation would be a modifier <code>unvahunzable</code> in the
language definition to protect certain classes, methods and attributes
from vahunzation.</p>
</BODY></HTML>
