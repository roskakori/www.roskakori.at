<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Vahunz - Tutorial</TITLE>
<LINK REV="owns" TITLE="Thomas Aglassinger" HREF="mailto:agi@giga.or.at">
<LINK REL="Next" HREF="tschak.html">
<LINK REL="Copyright" HREF="legal.html">
<LINK REL="Previous" HREF="requirements.html">
<META name="ROBOTS" content="NOINDEX, NOFOLLOW">
</HEAD><BODY>
<A HREF="index.html"><IMG SRC="image/main.gif" ALT="Contents" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<IMG SRC="image/noindex.gif" ALT="-----" ALIGN="middle" WIDTH="70" HEIGHT="16">
<A HREF="legal.html"><IMG SRC="image/copy.gif" ALT="Copyright" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="requirements.html"><IMG SRC="image/prev.gif" ALT="Previous" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="tschak.html"><IMG SRC="image/next.gif" ALT="Next" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<HR>
<H1>Tutorial</H1>
<P>The next paragraphs will describe how to actually vahunz a little
example program consisting of only a few source files. All terms and
techniques will be described when they are used first.</P>
<P>For most options, default values will be used, to make the whole
process easier to understand. You can set several options to modify
the behavior of Vahunz, but they will not be described in the
tutorial, but in the <A HREF="reference.html">reference</A> section
later on.</P>
<h2>The Example Sources</h2>
<P>The source files used during this tutorial can be found in
<i>vahunz/example</i>. To perform all the steps, you will have
to open a CLI and set its current directory to
<i>vahunz/example</i>.</P>
In the beginning, the example directory contains four files. Three of them
are simple ANSI-C source codes:
<UL>
<LI><i>sepp.c</i>, which holds <code>main()</code>
<LI><i>older.c</i>, which holds <code>grow_older()</code>, a function
called by <code>main()</code> in <i>sepp.c</i>
<LI><i>older.h</i> contains a prototype for <code>grow_older()</code>
and is included by <i>sepp.c</i>
</UL>
There also is one named <i>Makefile</i>, which is a simple
makefile describing how to compile the whole program for
<code>make</code>. This will not be touched by Vahunz.
<h2>Compiling the Example Program</h2>
<P>First, you do not need to compile the example program to continue
with this tutorial.</p>
<P>If you really want to, you will need a make-tool and an ANSI-C
compiler with a cc-like calling-syntax. By default, the makefile is
designed for <code>gcc</code>, but you can easily change the symbol
<code>CC</code> to <code>dcc</code> or whatever, if you like.</P>
<P>Any more details would be out of scope.</p>
<P>The program itself does nothing remarkable: it simulates a guy
named Sepp and lets him grow older until he dies. The output will look
like:

<PRE>
Sepp grows older.
Sepp is 79 years old.
Sepp grows older.
Sepp is 80 years old.
Sepp grows older.
Sepp is 81 years old.
Sepp grows older.
Sepp is 82 years old.
Sepp grows older.
Sepp is 83 years old.

Sepp died.
</PRE>
<P>There are only few variables and functions, and it should be straight
forward what is going on, even when you are unfamiliar to C.</P>
<h2>Creating the File List</h2>
<P>First of all, Vahunz needs to know which source files it should
touch. By default, it looks for a file named <i>vahunz.files</i>, which
will have to contain all filenames relative to the current directory.
Each filename has to be in an own line.</P>
In our case, we can easily create this list by typing:

<PRE>list &gt;vahunz.files (#?.c|#?.h) lformat="%p%n"</PRE>
This will create <i>vahunz.files</i> with the following content:

<PRE>
sepp.c
older.c
older.h
</PRE>
<P>Note that the <code>%p</code> in <CODE>LFORMAT</CODE> (for "path")
would not have been necessary in this case, as there are no files
located in any deeper sub-directories. However, it also did not cause
any harm, and you should provide it when creating the file list using
<code>list</code>.</P>
<P>More complex programs than this simple example often reside within
several directories, and then you will need to specify the full path
relative to the current directory. And this is exactly what
<code>%p</code> does.</P>
<P>Of course you can also create the file list manually, but this will
usually take longer and is more error prone.</P>
<h2>Creating the Dictionaries</h2>
Now it is time to build the dictionaries. That still is easy. Simply
invoke Vahunz without any arguments at all by typing into CLI:

<PRE>vahunz</PRE>
The output should look like this:

<PRE>
Vahunz - Make source code un-/more legible.
Version 1.7 (16.4.2001), (C) Thomas Aglassinger 1998

using `C' as language

reading existing files
  vahunz.files

building dictionaries
  sepp.c
  older.c
  older.h

writing dictionaries

The dictionary has been written to `vahunz.names'
and should be modified now.
</PRE>
<p>Although the program suggest to modify the dictionary right now, we
are going to do this a bit later. Therefor, the contents of
<i>vahunz.names</i> should look like this:</p>

<PRE>
 EXIT_SUCCESS
 age
 exit
 grow_older
 main
 name
 print_sepp
 printf
 sepp_age
 sepp_name
 stdio
 stdlib
</PRE>
<P>These are all names Vahunz could find within the source files
specified in the file list, omitting language specific keywords and
names shorter than three characters - these are considered to be
already unlegible.</P>
<P>Note that the first column entirely consist of blanks. Do not touch
anything yet.</P>
<h2>Your First Vahunzation</h2>
<P>As the dictionary now exists, Vahunz is ready to transform the
files. With the command line option <A HREF="reference.html#output"><code>--output</code></a> you can specify a
directory where the vahunzed files should end up. If you do not
specify one, <i>t:</i> will be used.</P>
<P>In this tutorial, for some reason it seems convenient to store the
vahunzed sources in <i>ram:vahunzed</i>. Therefor enter:</P>

<PRE>vahunz --output ram:vahunzed</PRE>
<P>There is no need to create the directory first, as this will be
done automatically when the first file is attempted to be written to
it.</P>
The interesting part of the output should look like this:

<PRE>
updating dictionaries
  sepp.c
  older.c
  older.h

building vahunzed dictionary in memory
  0 names vahunzed

writing dictionaries

writing vahunzed files
  ram:vahunzed (created)
  ram:vahunzed/sepp.c
  ram:vahunzed/older.c
  ram:vahunzed/older.h

3 files vahunzed.
</PRE>
<P>It tells that all source files have been rescanned and the name
list has been updated, in case there would have been any new names
since the creation. Of course, there weren't any yet, but its good to
know that Vahunz takes care of this.</P>
<P>It then states that "<CODE>0 names vahunzed</CODE>" which means all
the names are still meaningful. However, if you take a look at for
example <i>ram:vahunzed/sepp.c</i>, you will notice that all the
comments and indention are gone.</P>
<h2>Vahunzing Names</h2>
<P>To tell Vahunz to replace a meaningful name by some garbage, you
have to mark the first column in <i>vahunz.names</i> with a
"<code>+</code>". Load this file in your editor, and modify it so that
it looks something like this:

<PRE>
 EXIT_SUCCESS
+age
 exit
+grow_older
 main
+name
+print_sepp
 printf
+sepp_age
+sepp_name
 stdio
 stdlib
</PRE>
<P>Take care that you only change lines with names
<strong>you</strong> have created, and are not a function or constants
declared somewhere in the standard library, like for example
<code>printf</code> or <code>EXIT_SUCCESS</code>. The same applies to
<code>main</code> and <code>stdio</code>, as for obvious reasons the
program will not compile anymore when these names are garbled.</P>
Then again, invoke

<PRE>vahunz --output ram:vahunzed</PRE>
The output now has changed a bit. Most remarkable, it now tells:

<PRE>
  6 names vahunzed
</PRE>
<P>The 6 apparently corresponds to the number of "<code>+</code>" in
<i>vahunz.names</i>. If you now look at <i>ram:vahunzed/sepp.c</i>,
you will see that it looks a bit different as before. For example,
the original <code>main()</code> was:</P>

<PRE>
int main(void)
{
    while (sepp_age &lt; 83)
    {
        /* Simulate one year in the life of Sepp */
        grow_older(sepp_name, &amp;sepp_age);
        print_sepp();
    }

    /* Announce the bad news */
    printf("\n%s died.\n", sepp_name);

    /* World ends here. */
    exit(EXIT_SUCCESS);
}
</PRE>
The vahunzed version might look like this:

<PRE>
int main(void)
{
while (s2E &lt; 83)
{

z1I(d6T, &amp;s2E);
r0H();
}

printf("\n%s died.\n", d6T);

exit(EXIT_SUCCESS);
}
</PRE>
<P>The names do not necessarily have to look like this, as they are
created randomly on every invocation. In this case, for example
<code>grow_older</code> has been renamed to <code>z1I</code>.</P>
<P>When creating the names, Vahunz will take care that they do not
already exist for another substitute, and are also not used within the
names of original source. Usually they will have only three letters,
but if there are many names to garble, they can also become
longer.</P>
<P>But the best part: you can now copy the <i>Makefile</i> to
<i>ram:vahunzed</i>, recompile the program and execute it. You
will notice that it still does the same as before.</P>
<h2>Using a Dignorary</h2>
<P>Maybe you also noticed a files named <i>vahunz.ignore</i>. This one is
called <dfn>dignorary</dfn>. This strange word is derived from
<dfn>ignore</dfn> and <dfn>dictionary</dfn>, because that's exactly
what it is: a dictionary with names to be ignored (or: left untouched)
during vahunzation.</P>
Currently, it only consists of two lines
<PRE>
-older
-sepp
</PRE>
<P>Obviously, these are the names of our input files. Vahunz assumes
that the user does not want them to be replaced, as a possible <code>import</code>
or <code>#include</code> would fail then.</P>
<P>But the main feature is: the user does not see these names when he is
browsing the normal dictionary. Load <i>vahunz.names</i> into your editor
again, and change it that it looks like this:</P>

<PRE>
-EXIT_SUCCESS
+age
-exit
+grow_older
-main
+name
+print_sepp
-printf
+sepp_age
+sepp_name
-stdio
-stdlib
</PRE>
and invoke Vahunz as before:

<PRE>vahunz --output ram:vahunzed</PRE>
You will notice that all lines starting with a hyphen (<code>-</code>) have been moved
to <i>vahunz.ignore</i>, and therefor <i>vahunz.names</i> has become much cleaner.
<H2>What Next?</H2>
<P>This finishes the tutorial. You should now know how to utilize with
the basic concepts.</P>
<P>Still, there are some things to left, so you can use Vahunz more
efficient: There are some ready <A
href="dictionary.html">dignoraries</A> included in this distribution,
so for example you do not have to mark <code>printf</code>
manually.</P>
<P>There also exist several command line options, with most of them
being discussed in the use-cases or the reference section in the
later part of the manual.</P>
</BODY></HTML>
