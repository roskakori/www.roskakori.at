<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Vahunz - Known Problems</TITLE>
<LINK REV="owns" TITLE="Thomas Aglassinger" HREF="mailto:agi@giga.or.at">
<LINK REL="Next" HREF="source.html">
<LINK REL="Copyright" HREF="legal.html">
<LINK REL="Previous" HREF="beyond.html">
<META name="ROBOTS" content="NOINDEX, NOFOLLOW">
</HEAD><BODY>
<A HREF="index.html"><IMG SRC="image/main.gif" ALT="Contents" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<IMG SRC="image/noindex.gif" ALT="-----" ALIGN="middle" WIDTH="70" HEIGHT="16">
<A HREF="legal.html"><IMG SRC="image/copy.gif" ALT="Copyright" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="beyond.html"><IMG SRC="image/prev.gif" ALT="Previous" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="source.html"><IMG SRC="image/next.gif" ALT="Next" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<HR>
<H1>Known Problems</H1>
<P>The major problem of course is that if you have used the <B>same
name for different things</B> in your source code, or you decide to
vahunz a name you should not, it is easy to end up with vahunzed files
that do not even compile. This program is not idiot proof, because
this would required to implement huge parts of those things full
compilers do.</P>
<P>When <B>removing the indention</B>, there are still some blanks or
empty lines left. Use a language specific <a
href="beyond.html#strip-tools">strip tools</a> to avoid this.</P>
<P>The automatic <b>creation of output directories</b> is an
AmigaOS-only feature. The simple reason for that: there is no ANSI C
function for creating directories, and I don't know of any other C
standard that would support it (POSIX is no standard - it's an
illusion).</P>
<P>When you are doing very <B>funky stuff with the C-preprocessor</B>,
it might not work any more after vahunzation. This especially refers
to <code>##</code> and such things. In my opinion, this is a bug in
the design of the preprocessor, and a lack of brain if a programmer
really uses such things.</P>
<P>You must not <B>modify files during vahunzation</B>. For example,
you can change a source after the first pass, when all names have
already been retrieved. If now an unknown name shows up in the second
pass, Vahunz can no more ensure that all garbled name will not be the
same as the new unknown word, and will abort with an error.</P>
<P>If <B>carriage returns</B> (<code>\r</code>) show up in the input,
most of them will be gone in the output. If you use this tool on
source files coming from Macintosh (with <code>\r</code> as line
separator) or something worse (with <code>\r\n</code>), better use a
cr/lf-converter before vahunzing them.</P>
<P>There is a <B>limited line and name length</B> when reading the
lists for names and files. Currently this is 1023, which should be
sufficient to read most identifiers and filenames. If a line is too
long, the vahunz terminates with an error message. C-strings suck.</P>
<h1>Non-Issues</h1>
<P>The <B>number of names and files</B> is only limited by the
available memory. The source files do not have any limitations
concerning the line length or whole file size, as the are read
character-by-character.</P>
<P><B>Stack usage</B> should be very small, as most buffers are
allocated dynamically, and the tree functions are none-recursive.
Probably even the standard 4K are sufficient. Therefore, the program
is compiled without stack check.</P>
</BODY></HTML>
