<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>Vahunz - Inside Vahunz</TITLE>
<LINK REV="owns" TITLE="Thomas Aglassinger" HREF="mailto:agi@giga.or.at">
<LINK REL="Next" HREF="beyond.html">
<LINK REL="Copyright" HREF="legal.html">
<LINK REL="Previous" HREF="legal.html">
<META name="ROBOTS" content="NOINDEX, NOFOLLOW">
</HEAD><BODY>
<A HREF="index.html"><IMG SRC="image/main.gif" ALT="Contents" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<IMG SRC="image/noindex.gif" ALT="-----" ALIGN="middle" WIDTH="70" HEIGHT="16">
<A HREF="legal.html"><IMG SRC="image/copy.gif" ALT="Copyright" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="legal.html"><IMG SRC="image/prev.gif" ALT="Previous" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<A HREF="beyond.html"><IMG SRC="image/next.gif" ALT="Next" ALIGN="middle" WIDTH="70" HEIGHT="16"></A>
<HR>
<H1>Inside Vahunz</H1>
<p>Basically, Vahunz is just yet another search and replace tool.
Still, it does not simply scan for a character sausage inside another
character sausage because this would be far to slow if applied to the
huge amount of text to be expected.</p>
<p>Instead, there are some other mechanisms working behind. For those
who are interested, here is a short descriptions of them. You do not
need to know this stuff for simply using this program.</p>
<h2>Passes</h2>
<p>Vahunz has to read all source codes passed in
<i>vahunz.files</i> twice:</p>
<ul>
<li>The first pass creates the list of names in memory.
<li>The second pass read all files again, and checks for every name if
it should be replaced by some other text.
</ul>
<p>Between these two passes, the dictionaries on the disk are updated,
and the text for vahunzed names is created.</p>
<h2>Collecting Names</h2>
<p>Only whole words are taken into account. That means, characters are
added to one name until a character shows up that indicates the
beginning of a new name. Normal names consist of letters, digits and
underscores (<code>_</code>).</p>
<p>But even after a name is complete, it does not mean that it makes
sense to add it to the dictionary. Names matching one of the following
criteria are stored in the vahunzed target without any change :</p>
<ul>
<li>Short names according to <A HREF="reference.html#name-length"><code>--name-length</code></a>.
<li>Numeric values like <code>1234</code> and <code>0xbeef23</code>
<li>Special characters like mathematical operators
</ul>
<p>As such names do not need to be looked up in the name list, they
can be processed faster.</p>
<h2>Storing Names in Memory</h2>
<p>If one vahunzes dozens of files, there can be thousands of names in
them. When in the second pass, it has to be decided if and how to
vahunz a name after reading it from the input,</p>
<p>That means, for <em>every</em> name read (with the above
exceptions), the <em>whole</em> list of names has to be searched for
it, before a decision can be made.</p>
<p>As this list usually contains a lot of names, an efficient data
structure has to be used. In the case of Vahunz, this is an
AVL-tree. Such a tree is similar to the "classic" binary tree, but
avoids degeneration.</p>
<p>A lazy programmer does not write such tree functions himself. The
tree used here is part of the Ubiqx module library. You can obtain it from
<a href="http://www.interads.co.uk/~crh/ubiqx/index.html">http://www.interads.co.uk/~crh/ubiqx/index.html</a>.
</p>
<h2><a name="vahunzed-names">Vahunzed Names</a></h2>
<p>When a vahunzed name is created, the following steps are performed:</p>
<p>First, random letters and digits have to be appended until the name
is as long as specified with <A HREF="reference.html#vahunz-length"><code>--vahunz-length</code></a>. For that, every third letter
is chosen from a different set:</p>
<ul>
<li>A lower case letter (a-z)
<li>A digit (0-9)
<li>A upper case letter (A-Z)
</ul>
<p>The forth letter again is a lower case letter, and so on.</p>
<p>After the name is long enough, the list of names is scanned if the
one just created already exists. If not, it is accepted.</p>
<p>Otherwise further letters or digits are appended until no such
existing name can be found anymore. That means, every new letter
results in a name lookup, which takes more time than the simple
appending step described before.</p>
<p>In most cases, all vahunzed names will have three or maybe four
letters. Only when there are really a lot of files and names, you will
find longer ones.</p>
<p>Of course, all vahunzed names are also compaired with the
non-vahunzed names, so there can not be any accidental matches.</p>
<h2>Name Nodes</h2>
<p>Every name node in the tree stores the following data:</p>
<ul>
<li>The original name from the source code
<li>The possible target name to be vahunzed/renamed to
<li>The vahunz mode to be applied
<li>A usage counter how often the name has occurred in all sources.
This is only used for <A HREF="reference.html#no-unused"><code>--no-unused</code></a>.
</ul>
<p>The data structure is store in a way that there are only two calls
to <code>malloc()</code> required because all possible strings for one
node are stored within one memory area, only separated by a
<code>'\0'</code> character. This significantly reduces memory
fragmentation and the total amount of calls to the (slow)
<code>malloc()</code> and <code>free()</code> functions.</p>
<p>The reason why there is not even only one allocation used per node
is that the vahunzed names can only be created <em>after</em> all
names have been read from the input. But the length of a vahunzed name
is not known yet; <A HREF="reference.html#vahunz-length"><code>--vahunz-length</code></a> only gives a <em>lower</em>
limit. Therefor every vahunzed name requires a
<code>free()</code>/<code>malloc()</code> pair, which is the main
reason why the "<code>building vahunzed dictionary in memory</code>"
can take some time.</p>
</BODY></HTML>
